#bullshit first lines to prevent bugs
str

fn clone a = a

fn equals a b = a == b

fn true = 1
fn false = 0

fn pass -> (void) = 0

fn malloc n = sys_alloc n

fn free p = sys_free p

fn vecfmt = 0
fn mapfmt = 1

fn vec t = {
    cap = 8
    [
        cap = cap
        len = 0
        t = t
        mem = malloc cap * 8
        strfmt = vecfmt
        fn == a b = {
            | a.len != b.len : false
            | _ : {
                result = true
                for i a.len : | a[i] != b[i] : {
                    result = false
                    break
                }
                result
            }
        }
        fn != a b = {not (a == b)}
        fn % s e = {
            t = s.t
            t.(chr)
            result = ""
            skip = false
            applied = false
            for i s.len : {
                c = s[i]
                | skip : skip = false
                | c == '{' and $ (i != $ s.len - 1) and $ (s[i + 1] == '}') and $ not applied : {
                    skip = true
                    applied = true
                    vextend result tostr e
                }
                | _ : vpush result c
            }
            result
        }
        fn + a b = {
            result = a
            | eqtype a.t b : vpush result b
            | eqtype a b : result = vadd a b
            result
        }
        fn * v n = {
            n.(int)
            r = clone v
            for i 1 n : vextend r v
            | n == 0 : vclear r
            r
        }
        fn [] v i = {
            #checkoob v i
            #weakcast v.t memindex v.mem i 8
            sys_vget v i
        }
        fn []= v i e = {
            sys_vset v i e
        }
        fn copy v = {
            result = weakcast v malloc sizeof v
            result.cap = v.cap
            result.len = v.len
            result.t = v.t
            result.mem = malloc result.cap * 8
            result.strfmt = v.strfmt
            for i v.len : memindexset result.mem i 8 copy weakcast result.t memindex v.mem i 8
            result
        }
        fn drop v = {
            for i v.len : drop weakcast v.t memindex v.mem i 8
            | hasprop (v.t) _ : drop v.t
            free v.mem
        }
    ]
}

fn vpush v e = {
    vchecktype v e
    memindexset v.mem v.len 8 copy e
    v.len = v.len + 1
    | v.len == v.cap : {
        v.cap = v.cap * 2
        newmem = malloc v.cap * 8
        for i v.len : memindexset newmem i 8 memindex v.mem i 8
        free v.mem
        v.mem = newmem
    }
    e
}

fn vvoidpush v e -> (void) = {
    vchecktype v e
    memindexset v.mem v.len 8 copy e
    v.len = v.len + 1
    | v.len == v.cap : {
        v.cap = v.cap * 2
        newmem = malloc v.cap * 8
        for i v.len : memindexset newmem i 8 memindex v.mem i 8
        free v.mem
        v.mem = newmem
    }
}

fn exit c = cf (exit c)

fn oob l i -> (void) = {
    #print `Out of bounds length `
    #print l
    #print ` with index `
    #println i
    cf (printf `Out of bounds length %ld with index %ld` l i)
    exit 1
}

fn checkoob v i = {
    | i < 0 : oob v.len i
    | i >= v.len : oob v.len i
}

fn vchecktype v e = {
    u = v.t
    e.(u)
}

fn vget v i = {
    checkoob v i
    weakcast v.t memindex v.mem i 8
}

fn vqget v i = weakcast v.t memindex v.mem i 8

fn vset v i e = {
    vchecktype v e
    checkoob v i
    drop weakcast v.t memindex v.mem i 8
    memindexset v.mem i 8 copy weakcast v.t e #memindex v.mem i 8
    e
}

fn vqset v i e = {
    vchecktype v e
    drop weakcast v.t memindex v.mem i 8
    memindexset v.mem i 8 copy weakcast v.t e 
}

fn vhas v e = {
    result = 0
    for i v : | e == i : {
        result = 1
        break
    }
    result 
}

fn vextend a b = {
    for e b : vpush a e
}

fn vadd a b = {
    r = clone a
    vextend r b
    r
}

fn str = vec chr

fn vclear v = {
    for (v.len) : vpop v
    v
}

fn vpop v = vremove v v.len - 1

fn vreverse v = {
    result = vec v.t
    for i v.len : {
        vpush result v[v.len - i - 1]
    }
    result
}

fn inttostr n_ = {
    n = n_
    result = ""
    isneg = false
    | n < 0 : {
        isneg = true
        n = 0 - n
    }
    
    | n == 0 : result = "0"
    | _ : {
        for i 1 20 : {
            vpush result '0' + $ n % 10
            / n 10
            | n == 0 : break
        }
        | isneg : vpush result '-'
        result = vreverse result
    }
    result
}

fn flttostr n = {
    result = tostr toint n
    vpush result '.'
    for i 5 : {
        * n 10
        d = (toint n) % 10
        c = '0' + d
        vpush result c
    }
    result
}

fn structtostr e = {
    result = "[struct]"
    | e.strfmt == vecfmt : result = vtostr e
    | e.strfmt == mapfmt : result = mtostr e
    result
}

fn tostrextend s e = {
    result = ""
    | eqtype e str : result = e
    | eqtype e chr : vpush result e
    | eqtype e int : result = inttostr e
    | eqtype e flt : result = flttostr e
    | hasprop e strfmt : result = structtostr e
    | hasprop e _ : result = sys_structtostr e
    vextend s result
    s
}

fn tostr e = tostrextend "" e

fn vremove v index = {
    checkoob v index
    result = v[index]
    drop weakcast v.t memindex v.mem index 8
    for i index v.len - 1 : {
        memindexset v.mem i 8 memindex v.mem i+1 8
    }
    - v.len 1
    ncap is v.cap / 4
    | v.len < ncap : {
        v.cap = ncap
        newmem = malloc v.cap * 8
        for i v.len : memindexset newmem i 8 memindex v.mem i 8
        free v.mem
        v.mem = newmem
    }
    result
}

fn vfind v e = {
    r = -1
    for i v.len : {
        f = v[i]
        | f == e : {
            r = i
            break
        }
    }
    r
}

fn vhas v e = (vfind v e) != (-1)

fn vslice v s e = {
    r = vec v.t
    for i s e : vpush r v[i]
    r
}

fn vtostr v = {
    r = "["
    | hasprop v len : {
        for e v : {
            vextend r (tostr e) + ", "
        }
        | r != "[" : {
            vpop r
            vpop r
        }
        vpush r ']'
    }
    r
}

fn mtostr v = {
    r = "["
    for e v.keys : {
        vextend r (tostr e) + ": " + (tostr v[e]) + ", "
    }
    | r != "[" : {
        vpop r
        vpop r
    }
    vpush r ']'
    r
}

fn vfindstr v s = {
    result = -1
    for i v.len-s.len+1 : {
        | (vslice v i i + s.len) == s : {
            result = i 
            break 
        } 
    } 
    result 
} 
 
fn vhasstr v s = (vfindstr v s) != -1

fn nosuchkey k -> (void) = {
    println $"Error: map has no such key '{k}'"
    exit 1
}

fn _map kt_ vt_ = [
    keys = vec kt_
    values = vec vt_
    strfmt = mapfmt
    fn [] m k = {
        k.((m.keys).t)
        | not vhas mkeys m k : nosuchkey k
        resulti = 0
        for i m.keys.len : | m.keys[i] == k : resulti = i
        m.values[resulti]
    }
    fn []= m i e = {
        mset m i e
    }
]

fn map k v = {
    result is _map k v 
    | false : result[k]
    result
}
 
fn mset m k v = {
    k.(m.keys.t)
    v.(m.values.t)
    found = false
    for i m.keys.len : {
        key = m.keys[i]
        | key == k : {
            found = true
            m.values[i] = v
            break
        }
    }
    | not found : {
        vpush m.keys k
        vpush m.values v
    }
    v
}

fn mget m k = {
    #k.(m.keys.t)
    #result = vget m.values 0
    #for i m.keys.len : | (vget m.keys i) == k : result = vget m.values i
    #result
    k.((m.keys).t)
    | not m.keys m k : nosuchkey k
    result = m.values[0]
    for i m.keys.len : | m.keys[i] == k : result = m.values[i]
    result
}

fn mhaskey m k = vhas m.keys k

fn newline = weakcast chr 10

fn oldprint e = {
    strtype = vec chr
    | eqtype e int : cf (printf `%ld` e)
    | eqtype e chr : cf (printf `%c` e)
    | eqtype e flt : cf (printdub e)
    | eqtype e mem : cf (printf `%s` e)
    | eqtype e strtype : for c e : cf (printf `%c` c)
    #| _ : for c (tostr e) : cf (printf `%c` c)
    e
}

fn print e = {
    oldprint tostr e
}

fn println e = {
    print e
    print newline
    e
}

fn argc = sys_argc

fn cstrtovec s = {
    result = ""
    i = 0
    for (memindex s i 1) : {
        vpush result weakcast chr memindex s i 1
        i = i + 1
    }
    result
}

fn vectocstr s = {
    assert (s.len >= 0) "string of negative length"
    result = malloc s.len + 1
    for i s.len : memindexset result i 1 vget s i
    memindexset result s.len 1 0
    result
}

fn argv = {
    result = vec vec chr
    for i argc : {
        vpush result cstrtovec memindex sys_argv i 8
    }
    result
}

fn pstrtovec s = {
    result = ""
    len = weakcast int memindex s 0 8
    for i len : vpush result weakcast chr memindex s i + 8 1
    result
}

fn vectopstr s = {
    result = malloc s.len + 8
    memindexset result 0 8 s.len 
    for i s.len : memindexset result i + 8 1 s[i]
    result
}

fn readfile s = {
    cfname = vectocstr s
    contents = cf (readfile cfname)
    result = pstrtovec contents
    free cfname
    cf (free contents)
    result
}

fn writefile s text = {
    cfname = vectocstr s
    ctext = vectopstr text 
    cf (writefile cfname ctext)
    free cfname
    free ctext
    text
}

fn cisdigit c = (c >= '0') or (c <= '9')

fn strtoint ss = {
    s = vtrim ss
    | vhas s '.' : toint toflt s
    | _ : {
        result = 0
        p = -1
        for (s.len) : {
            c is vpop s
            | cisdigit c : + result (toint c - '0') * pow 10 (+ p 1)
            | _ : {
                result = 0
                break
            }
        }
        result
    }
}

fn toint a -> int = {
    | eqtype a flt : weakcast int cf (dubtolong a)
    | eqtype a str : strtoint a
    | _ : weakcast int a
}

fn strtoflt ss = {
    orig = vtrim ss
    sp = vsplit orig "."
    s = sp[0]
    d = sp[1]
    iresult = 0
    p = -1
    for (s.len) : {
        c = vpop s
        | cisdigit c : + iresult (toint c - '0') * pow 10 (+ p 1)
        | _ : {
            iresult = 0
            break
        }
    }
    dresult = 0.0
    dec = 0.1
    d = vreverse d
    for (d.len) : {
        c = vpop d
        | cisdigit c : + dresult (toint c - '0') * dec
        | _ : {
            dresult = 0.0
            break
        }
        / dec 10
    }
    iresult + dresult
}

fn toflt a = { 
    | eqtype a flt : weakcast flt a
    | eqtype a str : strtoflt a
    | _ : weakcast flt cf (longtodub a)
}

fn tochr n = {
    i is toint n 
    weakcast chr i
}

fn system s = {
    cs = vectocstr s
    result = cf (system cs)
    free cs
    result
}

fn getchar = weakcast chr cf (getchar)

fn readline = {
    result = ""
    c = getchar
    for (c != '\n') : {
        vpush result c
        c = getchar
    }
    result
}

fn readeof = {
    result = ""
    c = getchar
    for (c < 255) and (c >= 0) : {
        vpush result c
        c = getchar
    }
    result
}

fn vfilter list f = {
    result = vec list.t
    for e list : {
        | * f e : vpush result e
    }
    result
}

fn vsplit s sp = {
    result = vec str
    line = ""
    for i s.len : {
        c = s[i] 
        | (vslice s i i + sp.len) == sp : {
            vpush result line
            line = ""
            + i sp.len - 1
        }
        | _ : {
            vpush line c
        }
    }
    | line.len : vpush result line
    result
}

fn vmap l f = {
    result = vec l.t
    for e l : {
        ne is * f e
        ne.(l.t)
        vpush result ne
    }
    result
}

fn veach l f = for e l : \> f e

fn range start end = {
    result = vec int
    for i start end : vpush result i 
    result
}

fn vrep val rep = {
    result = vec val 
    for i rep : vpush result val 
    result
}

fn sleep n = cf (msleep toint n * 1000)

fn mkeys m = m.keys
fn mvalues m = m.values

fn mextend a b = {
    keys = b.keys
    for k keys : a[k] = b[k]
    a
}

fn vjoin v s = {
    result = ""
    | v.len : {
        for i v.len - 1 : {
            vextend result tostr v[i] + s
        }
        vextend result v[v.len - 1]
    }
    result
}

fn vtrim ^s = {
    | s.len : {
        whitespace = [' ' '\t' '\n']
        for (s.len and vhas whitespace s[0]) : vremove s 0
        for (s.len and vhas whitespace s[s.len - 1]) : vremove s s.len - 1
    }
    s
}

fn assert c s = {
    | not c : {
        println $"Assertion error: {s}"
        exit 1
    }
}

fn ismac = cf (ismac)
fn islinux = cf (islinux)

fn cisupper c = (c >= 'A') and (c <= 'Z')
fn cislower c = (c >= 'a') and (c <= 'z')

fn ctoupper c = {
    diff = 'A' - 'a'
    | cislower c : c + diff
    | _ : c
}

fn ctolower c = {
    diff = 'A' - 'a'
    | cisupper c : c - diff
    | _ : c
}

fn vtoupper ^s = {
    for i s.len : s[i] = ctoupper s[i]
    s
}

fn vtolower ^s = {
    for i s.len : s[i] = ctolower s[i] 
    s
}

fn carray pointer = [
    use...
    esize = 8
    fn [] a i = {
        case a.esize : {
            1 : memindex a.pointer i 1
            2 : memindex a.pointer i 2
            4 : memindex a.pointer i 4
            8 : memindex a.pointer i 8
            _ : {    
                println "bad carray size"
                exit 1
                memindex a.pointer i 1
            }
        }
    }
    fn []= a i e = { 
        case a.esize : {
            1 : memindexset a.pointer i 1 e
            2 : memindexset a.pointer i 2 e
            4 : memindexset a.pointer i 4 e
            8 : memindexset a.pointer i 8 e
            _ : {     
                println "bad carray size"
                exit 1 
            } 
        }
        e
    } 
]

fn cos n = weakcast flt cf (hpcos toflt n)
fn sin n = weakcast flt cf (hpsin toflt n)
fn acos n = weakcast flt cf (hpacos toflt n)
fn asin n = weakcast flt cf (hpasin toflt n)
fn atan2 a b = weakcast flt cf (hpatan2 toflt a toflt b)
fn pi = weakcast flt cf (hppi)
fn sqrt n = weakcast flt cf (hpsqrt toflt n)

fn pow b p -> (int) = {
    | p : b * pow b p - 1
    | _ : 1 
} 
fn lsh n s = n * pow 2 s

fn epochms = toint cf (epochms)

fn utcw = epochms / 1000 / 60 / 60 / 24 + 3 % 7
fn utch = epochms / 1000 / 60 / 60 % 24
fn utcm = epochms / 1000 / 60 % 60

fn forkwith f = {
    id is toint cf (fork)
    | not id : { *f; exit 0 } 
    id 
}

fn forkwithargs f a = {
    id is toint cf (fork)
    | not id : { *f a; exit 0 } 
    id 
}

fn abs n = {
    | n >= 0 : n
    | _ : 0 - n
}

glo sys_randseed = 0
fn randint = {
    | not sys_randseed : glo sys_randseed = epochms
    glo sys_randseed = abs sys_randseed * 17669 + 94201 / 10
}

fn readoutput cmd = {
    result = ""
    ccmd is vectocstr cmd
    p is cf (popen ccmd `r`)
    free ccmd
    i = 0
    for (not cf (feof p)) : {
        + result ' '
        memindexset result.mem ((result.len - 1) * 8) 1 (cf (fgetc p))
    }
    vpop result
    result
}


#bullshit to prevent asm errors
["h" : "h"]
